# -*- coding: utf-8 -*-
"""
"""
from enaml.core.api import Looper, Conditional
from enaml.widgets.api import (DockItem, Container, Menu, Action, Dialog,
                               PushButton, ToolBar, Action, Notebook, Page,
                               ObjectCombo, RadioButton, Label)
from enaml.stdlib.mapped_view import MappedView
from enaml.layout.api import InsertItem, hbox, vbox, spacer, grid, factory
from ...utils.ui.qt_list_str_widget import QtListStrWidget
from .curves import SimpleCurve1DInfos, SumCurve1DInfos


enamldef AbstractCurveConfig(Container):
    """
    """
    attr plot
    attr curve

    # Plot config.
    # TODO later


def _sc_constraints(container, wrap=3):
    """
    """
    widgets = container.visible_widgets()
    return [vbox(grid(*[widgets[i:i+wrap] for i in range(0, len(widgets),
                                                         wrap)]))]


enamldef SimpleCurveConfig(AbstractCurveConfig): main:
    """
    """
    attr _data

    initialized ::
        if curve.m_name:
            for p in plot.experiment.plottable_data.values():
                if curve.m_name == p['m_name']:
                    main._data = p
                    break
    Container:
        constraints << [factory(_sc_constraints, 3)]
        Looper: lp:
            iterable << plot.experiment.plottable_data.items()
            RadioButton:
                text = loop_item[0]
                checked << curve.m_name == loop_item[1]['m_name']
                toggled ::
                    curve.m_name = loop_item[1]['m_name']
                    curve.indexes = tuple(0 for i in range(loop_item[1]['dim']))
                    main._data = loop_item[1]

    Conditional: cd1:
        condition << bool(_data and _data['dim'] == 1)
        Container:
            constraints << [factory(_sc_constraints, 5)]
            Looper: lp1:
                iterable << _data['map']
                RadioButton:
                    text = loop_item
                    checked << curve.indexes[0] == loop_index
                    toggled :: curve.indexes = (loop_index,)

    # XXXX need fixes (nested Looper does not work)
    Conditional: cd2:
        condition << bool(_data and _data['dim'] == 2)
        Looper:
            iterable << _data['map']
            Container:
                attr it = loop_item
                attr ind = loop_index
                Looper: lp2:
                    iterable << it
                    RadioButton:
                        text = loop_item
                        checked << curve.indexes[ind] == loop_index
                        toggled ::
                            aux = list(curve.indexes)
                            aux[ind] = loop_index
                            curve.indexes = tuple(aux)


enamldef SumCurveConfig(AbstractCurveConfig):
    """
    """
    pass
    # Radio buttons generated from the experiment plottable vars keys (if dim is one)
    #   This gives the member name.
    # Checkboxes generated from the experiment plottable map
    #   This gives the indexes to use.


CURVE_CONFIG_MAP = {SimpleCurve1DInfos: SimpleCurveConfig,
                    SumCurve1DInfos: SumCurveConfig,
                    type(None): AbstractCurveConfig}

def _find_id(infos):
    """
    """
    used = [i.id for i in infos]
    pot_free = ['curve_{}'.format(i) for i in range(len(used))]
    for id in pot_free:
        if id not in used:
            return id

    return 'curve_{}'.format(len(used))


enamldef Curves1DConfig(Container): main:
    """
    """
    attr plot
    event curves_updated ::
        c_list.items = [c.id for c in plot.y_infos]
        c_list.refresh_items()
        # Here take cares of rebuilding the list of curves.
    attr _selected

    constraints << [hbox(c_list, vbox(c_lab, c_info,
                                      *list(c_map.objects)+[spacer]),
                         vbox(add, rem, spacer))]

    QtListStrWidget: c_list:
        # Display list of curve names
        items << sorted([c.id for c in plot.y_infos])
        selected_item ::
            for i in plot.y_infos:
                if i.id == selected_item:
                    main._selected = i
                    break

    Label: c_lab:
        text << _selected.id if _selected else ''

    ObjectCombo: c_info:
        enabled << bool(_selected)
        # Allow to change the kind of curve
        items = sorted(CURVE_INFOS.values())
        selected << CURVE_INFOS[type(_selected)] if _selected else None
        selected ::
            for c in CURVE_INFOS:
                if CURVE_INFOS[c] == selected and type(main._selected) != c:
                    new = c(id=main._selected.id)
                    if main._selected in main.plot.y_infos:
                        main.plot.replace_curves(main._selected, new)
                    else:
                        main.plot.add_curves([new])
                    main._selected = new
                    break

    MappedView: c_map:
        # View associated to the currently selected curve.
        model << _selected
        typemap = CURVE_CONFIG_MAP
        kwargs = {'plot': plot}
        modelkey = 'curve'

    PushButton: add:
        # Way to add a new curve.
        text = 'Add'
        clicked ::
            id_ = _find_id(plot.y_infos)
            new = SimpleCurve1DInfos(id=id_)
            plot.add_curves([new])
            main.curves_updated = True
            main._selected = new

    PushButton: rem:
       # Way to remove the currently selected curve.
       text = 'Remove'
       clicked ::
           aux = plot.y_infos
           plot.remove_curves([_selected])
           main._selected = None
           main.curves_updated = True
