# -*- coding: utf-8 -*-
"""
"""
from operator import itemgetter
from enaml.core.api import Looper, Conditional
from enaml.widgets.api import (DockItem, Container, Menu, Action, Dialog,
                               PushButton, ToolBar, Action, Notebook, Page,
                               ObjectCombo, RadioButton, Label, CheckBox,
                               FlowArea, FlowItem)
from enaml.stdlib.mapped_view import MappedView
from enaml.layout.api import InsertItem, hbox, vbox, spacer, grid, factory
from ...utils.ui.qt_list_str_widget import QtListStrWidget
from .curves import SimpleCurve1DInfos, SumCurve1DInfos, CURVE_INFOS


enamldef AbstractCurveConfig(Container):
    """
    """
    attr plot
    attr curve

    # Plot config.
    # TODO later


def _sc_constraints(container, wrap=3):
    """
    """
    widgets = container.visible_widgets()
    return [vbox(grid(*[widgets[i:i+wrap] for i in range(0, len(widgets),
                                                         wrap)]))]

def _plottable_(plottable_data):
    """ Build a list of pair used to build the curve view.

    It duplicates the entries for complex between Re and imaginary parts.

    """
    items = []
    for name, meta in plottable_data.items():
        if meta['dtype'] == 'float':
            items.append((name, meta))
        else:
            real = meta.copy()
            real['dtype'] = 'real'
            imag = meta.copy()
            imag['dtype'] = 'imag'
            items.extend([('Re({})'.format(name), real),
                          ('Im({})'.format(name), imag)])
    return sorted(items, key=itemgetter(0))

enamldef SimpleCurveConfig(AbstractCurveConfig): main:
    """
    """
    attr _data

    initialized ::
        if curve.m_name:
            for p in plot.experiment.plottable_data.values():
                if curve.m_name == p['m_name']:
                    main._data = p
                    break
    FlowArea:
        Looper: lp:
            iterable << _plottable_(plot.experiment.plottable_data)
            FlowItem:
                Container:
                    padding = 0
                    RadioButton:
                        text = loop_item[0]
                        checked << bool(curve.m_name == loop_item[1]['m_name']
                                        and
                                        curve.part == loop_item[1]['dtype'])
                        toggled ::
                            curve.m_name = loop_item[1]['m_name']
                            curve.indexes = tuple(0 for i in
                                                  range(loop_item[1]['dim']))
                            curve.part = loop_item[1]['dtype']
                            main._data = loop_item[1]

    Conditional: cd1:
        condition << bool(_data and _data['dim'] == 1)
        FlowArea:
            Looper: lp1:
                iterable << _data['map']
                FlowItem:
                    Container:
                        padding = 0
                        RadioButton:
                            text = loop_item
                            checked << curve.indexes[0] == loop_index
                            toggled :: curve.indexes = (loop_index,)

    # XXXX need fixes (nested Looper does not work)
    Conditional: cd2:
        condition << bool(_data and _data['dim'] == 2)
        Looper:
            iterable << _data['map']
            Container:
                attr it = loop_item
                attr ind = loop_index
                Looper: lp2:
                    iterable << it
                    RadioButton:
                        text = loop_item
                        checked << curve.indexes[ind] == loop_index
                        toggled ::
                            aux = list(curve.indexes)
                            aux[ind] = loop_index
                            curve.indexes = tuple(aux)


enamldef SumCurveConfig(AbstractCurveConfig): main:
    """
    """
    attr _data

    initialized ::
        if curve.m_name:
            for p in plot.experiment.plottable_data.values():
                if curve.m_name == p['m_name']:
                    main._data = p
                    break
    FlowArea:
        Looper: lp:
            iterable << _plottable_(plot.experiment.plottable_data)
            FlowItem:
                Container:
                    padding = 0
                    RadioButton:
                        text = loop_item[0]
                        checked << bool(curve.m_name == loop_item[1]['m_name']
                                        and
                                        curve.part == loop_item[1]['dtype'])
                        toggled ::
                            curve.m_name = loop_item[1]['m_name']
                            curve.indexes = [tuple(0 for i in
                                                  range(loop_item[1]['dim']))]
                            curve.part = loop_item[1]['dtype']
                            main._data = loop_item[1]

    Conditional: cd1:
        condition << bool(_data and _data['dim'] == 1)
        FlowArea:
            Looper: lp1:
                iterable << _data['map']
                FlowItem:
                    Container:
                        padding = 0
                        CheckBox:
                            text = loop_item
                            checked << bool((loop_index,) in curve.indexes)
                            toggled ::
                                if change['value']:
                                    aux = curve.indexes[:]
                                    aux.append((loop_index,))
                                    curve.indexes = aux
                                else:
                                    aux = curve.indexes[:]
                                    if (loop_index,) in aux:
                                        aux.remove((loop_index,))
                                    curve.indexes = aux


CURVE_CONFIG_MAP = {SimpleCurve1DInfos: SimpleCurveConfig,
                    SumCurve1DInfos: SumCurveConfig,
                    type(None): AbstractCurveConfig}

def _find_id(infos):
    """
    """
    used = [i.id for i in infos]
    pot_free = ['curve_{}'.format(i) for i in range(len(used))]
    for id in pot_free:
        if id not in used:
            return id

    return 'curve_{}'.format(len(used))


enamldef Curves1DConfig(Container): main:
    """
    """
    attr plot
    event curves_updated ::
        c_list.items = [c.id for c in plot.y_infos]
        c_list.refresh_items()
        # Here take cares of rebuilding the list of curves.
    attr _selected

    constraints << [hbox(c_list, vbox(c_lab, c_info,
                                      *list(c_map.objects)+[spacer]),
                         vbox(add, rem, spacer)),
                    c_lab.width >= c_list.width]

    QtListStrWidget: c_list:
        # Display list of curve names
        items << sorted([c.id for c in plot.y_infos])
        selected_item ::
            for i in plot.y_infos:
                if i.id == selected_item:
                    main._selected = i
                    break

    Label: c_lab:
        text << _selected.id if _selected else ''

    ObjectCombo: c_info:
        enabled << bool(_selected)
        # Allow to change the kind of curve
        items = sorted(CURVE_INFOS.values())
        selected << CURVE_INFOS[type(_selected)] if _selected else None
        selected ::
            for c in CURVE_INFOS:
                if CURVE_INFOS[c] == selected and type(main._selected) != c:
                    new = c(id=main._selected.id)
                    if main._selected in main.plot.y_infos:
                        main.plot.replace_curve(main._selected, new)
                    else:
                        main.plot.add_curves([new])
                    main._selected = new
                    break

    MappedView: c_map:
        # View associated to the currently selected curve.
        model << _selected
        typemap = CURVE_CONFIG_MAP
        kwargs = {'plot': plot}
        modelkey = 'curve'

    PushButton: add:
        # Way to add a new curve.
        text = 'Add'
        clicked ::
            id_ = _find_id(plot.y_infos)
            new = SimpleCurve1DInfos(id=id_)
            plot.add_curves([new])
            main.curves_updated = True
            main._selected = new

    PushButton: rem:
       # Way to remove the currently selected curve.
       text = 'Remove'
       clicked ::
           aux = plot.y_infos
           plot.remove_curves([_selected])
           main._selected = None
           main.curves_updated = True
